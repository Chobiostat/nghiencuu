---
title: foreach
layout: post
---

<div id="post-73934" class="post-73934 post type-post status-publish format-standard hentry category-r-bloggers">

# The Wonders of foreach

<div class="meta">

<div class="date">August 25, 2013</div>

By [andrew](https://www.r-bloggers.com/author/andrew/ "Posts by andrew")</div>

<div class="entry">

<div class="social4i" style="height:29px;" onrj5fv="" hidden="">

<div class="social4in" style="height:29px;float: left;">

<div class="socialicons s4fblike" style="float:left;margin-right: 10px;" onrj5fv="" hidden="">

<div class="fb-like fb_iframe_widget" data-href="https://www.r-bloggers.com/the-wonders-of-foreach/" data-send="true" data-layout="button_count" data-width="100" data-height="21" data-show-faces="false" onrj5fv="" hidden="" fb-xfbml-state="rendered" fb-iframe-plugin-query="app_id=&amp;container_width=0&amp;height=21&amp;href=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F&amp;layout=button_count&amp;locale=en_US&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=100"><span style="vertical-align: bottom; width: 111px; height: 20px;"><iframe name="f3fa7d860ba6c" width="100px" height="21px" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" title="fb:like Facebook Social Plugin" src="https://www.facebook.com/plugins/like.php?app_id=&amp;channel=https%3A%2F%2Fstaticxx.facebook.com%2Fconnect%2Fxd_arbiter%2Fr%2F0sTQzbapM8j.js%3Fversion%3D42%23cb%3Df3d657c225913dc%26domain%3Dwww.r-bloggers.com%26origin%3Dhttps%253A%252F%252Fwww.r-bloggers.com%252Ff13959dd16d1716%26relation%3Dparent.parent&amp;container_width=0&amp;height=21&amp;href=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F&amp;layout=button_count&amp;locale=en_US&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=100" style="border: none; visibility: visible; display: none !important; width: 111px; height: 20px;" hidden="" class=""></iframe></span></div>

</div>

</div>

</div>

<div style="border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 12px;">(This article was first published on **[Exegetic Analytics » R](http://www.exegetic.biz/blog/2013/08/the-wonders-of-foreach/)**, and kindly contributed to [R-bloggers)](https://www.r-bloggers.com/)</div>

<aside class="mashsb-container mashsb-main mashsb-stretched" onrj5fv="" hidden="">

<div class="mashsb-box" onrj5fv="" hidden="">

<div class="mashsb-count mash-small" style="float:left;">

<div class="counts mashsbcount">28</div>

<span class="mashsb-sharetext">SHARES</span></div>

<div class="mashsb-buttons">[<span class="icon"></span><span class="text">Share</span>](https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F)[<span class="icon"></span><span class="text">Tweet</span>](https://twitter.com/intent/tweet?text=The%20Wonders%20of%20foreach&url=https://www.r-bloggers.com/the-wonders-of-foreach/&via=Rbloggers)</div>

</div>

</aside>

Writing code from scratch to do parallel computations can be rather tricky. However, the packages providing parallel facilities in R make it remarkably easy. One such package is [foreach](http://r.adu.org.za/web/packages/foreach/index.html). I am going to document my trail of discovery with foreach, which began some time ago, but has really come into fruition over the last few weeks.

First we need a reproducible example. Preferably something which is numerically intensive.

<div>

<div id="highlighter_921417" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`> max.eig <-` `function``(N, sigma) {`</div>

<div class="line number2 index1 alt1">`+     d <-` `matrix``(``rnorm``(N**2, sd = sigma), nrow = N)`</div>

<div class="line number3 index2 alt2">`+    ` `#`</div>

<div class="line number4 index3 alt1">`+     E <-` `eigen``(d)$values`</div>

<div class="line number5 index4 alt2">`+    ` `#`</div>

<div class="line number6 index5 alt1">`+    ` `abs``(E)[[1]]`</div>

<div class="line number7 index6 alt2">`+ }`</div>

</div>

 |

</div>

</div>

This function generates a square matrix of uniformly distributed random numbers, finds the corresponding (complex) eigenvalues and then selects the eigenvalue with the largest modulus. The dimensions of the matrix and the standard deviation of the random numbers are given as input parameters.

<div>

<div id="highlighter_850924" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `max.eig``(5, 1)`</div>

<div class="line number2 index1 alt1">`[1] 2.180543`</div>

<div class="line number3 index2 alt2">`>` `max.eig``(5, 1)`</div>

<div class="line number4 index3 alt1">`[1] 1.922373`</div>

</div>

 |

</div>

</div>

Since the data are random, each function call yields a different result.

# Vectorised

It would be interesting to look at the distribution of these results. We can produce a multitude of such results using vectorised multiple invocations of the function.

<div>

<div id="highlighter_813364" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`> E =` `sapply``(1:10000,` `function``(n) {``max.eig``(5, 1)})`</div>

<div class="line number2 index1 alt1">`>` `summary``(E)`</div>

<div class="line number3 index2 alt2">`Min. 1st Qu.  Median    Mean 3rd Qu.    Max.`</div>

<div class="line number4 index3 alt1">`0.7615  1.9150  2.2610  2.3160  2.6470  5.2800`</div>

</div>

 |

</div>

</div>

Here eigenvalues are calculated from 10000 function calls, all of which use the same parameters. The distribution of the resulting eigenvalues is plotted in the histogram below. Generating these data took a couple of seconds on my middle-of-the-range laptop. Not a big wait. But it was only using one of the four cores on the machine, so in principle it could have gone faster.

[![eigenvalue-histogram](https://i1.wp.com/www.exegetic.biz/blog/wp-content/uploads/2013/08/eigenvalue-histogram.png?w=450)

<noscript><img class="aligncenter size-full wp-image-409" alt="eigenvalue-histogram" src="https://i1.wp.com/www.exegetic.biz/blog/wp-content/uploads/2013/08/eigenvalue-histogram.png?w=450" data-recalc-dims="1" /></noscript>

](https://i1.wp.com/www.exegetic.biz/blog/wp-content/uploads/2013/08/eigenvalue-histogram.png)

We can make things more interesting by varying the dimensions of the matrix.

<div>

<div id="highlighter_776405" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `sapply``(1:5,` `function``(n) {``max.eig``(n, 1)})`</div>

<div class="line number2 index1 alt1">`[1] 0.1107296 2.4150209 1.5316894 1.4639843 1.5902372`</div>

</div>

 |

</div>

</div>

Or changing both the dimensions (taking on integral values between 1 and 5) and the standard deviation (running through 1, 2 and 3).

<div>

<div id="highlighter_842586" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `sapply``(1:5,` `function``(n) {``sapply``(1:3,` `function``(m) {``max.eig``(n, m)})})`</div>

<div class="line number2 index1 alt1">`[,1]      [,2]     [,3]     [,4]     [,5]`</div>

<div class="line number3 index2 alt2">`[1,] 1.6510105 0.5055719 2.053653 3.100523 2.440287`</div>

<div class="line number4 index3 alt1">`[2,] 0.3927822 0.4253438 2.936822 2.567797 4.057999`</div>

<div class="line number5 index4 alt2">`[3,] 5.8680964 2.9921687 3.571913 9.384722 3.827924`</div>

</div>

 |

</div>

</div>

The results are presented in an intuitive matrix. Everything up to this point is being done serially.

# Enter foreach

<div>

<div id="highlighter_285859" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `library``(foreach)`</div>

</div>

 |

</div>

</div>

At first sight, the foreach library provides a slightly different interface for vectorisation. We’ll start off with simple repetition.

<div>

<div id="highlighter_580759" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `times``(10) %do%` `max.eig``(5, 1)`</div>

<div class="line number2 index1 alt1">`[1] 1.936434 1.679151 2.507670 2.547832 2.292036 2.783489 2.545161 2.370996 2.904912 3.063622`</div>

</div>

 |

</div>

</div>

That just executes the function with the same arguments 10 times over. If we want to systematically vary the parameters, then instead of times() we use foreach().

<div>

<div id="highlighter_565942" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5) %do%` `max.eig``(n, 1)`</div>

<div class="line number2 index1 alt1">`[[1]]`</div>

<div class="line number3 index2 alt2">`[1] 0.4220093`</div>

<div class="line number5 index4 alt2">`[[2]]`</div>

<div class="line number6 index5 alt1">`[1] 0.8011105`</div>

<div class="line number8 index7 alt1">`[[3]]`</div>

<div class="line number9 index8 alt2">`[1] 1.45409`</div>

<div class="line number11 index10 alt2">`[[4]]`</div>

<div class="line number12 index11 alt1">`[1] 2.345526`</div>

<div class="line number14 index13 alt1">`[[5]]`</div>

<div class="line number15 index14 alt2">`[1] 1.846834`</div>

</div>

 |

</div>

</div>

The results are returned as a list, which is actually more reminiscent of the behaviour of lapply() than sapply(). But we can get something more compact by using the .combine option.

<div>

<div id="highlighter_893636" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5, .combine = c) %do%` `max.eig``(n, 1)`</div>

<div class="line number2 index1 alt1">`[1] 1.758172 2.601491 1.132095 2.106668 2.280279`</div>

</div>

 |

</div>

</div>

That’s better. Now, what about varying both the dimensions and standard deviation? We can string together multiple calls to foreach() using the %:% nesting operator.

<div>

<div id="highlighter_952726" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5) %:%` `foreach``(m = 1:3) %do%` `max.eig``(n, m)`</div>

</div>

 |

</div>

</div>

I have omitted the output because it consists of nested lists: it’s long and somewhat ugly. But again we can use the .combine option to make it more compact.

<div>

<div id="highlighter_149179" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5, .combine = rbind) %:%` `foreach``(m = 1:3) %do%` `max.eig``(n, m)`</div>

<div class="line number2 index1 alt1">`[,1]      [,2]     [,3]`</div>

<div class="line number3 index2 alt2">`result.1 0.2602969 1.285972 6.455814`</div>

<div class="line number4 index3 alt1">`result.2 1.113325  4.203023 6.828937`</div>

<div class="line number5 index4 alt2">`result.3 1.28568   2.711026 4.338442`</div>

<div class="line number6 index5 alt1">`result.4 1.222587  4.88346  6.826418`</div>

<div class="line number7 index6 alt2">`result.5 1.722572  6.197047 5.878693`</div>

<div class="line number8 index7 alt1">`>` `foreach``(n = 1:5, .combine = cbind) %:%` `foreach``(m = 1:3) %do%` `max.eig``(n, m)`</div>

<div class="line number9 index8 alt2">`result.1  result.2 result.3 result.4 result.5`</div>

<div class="line number10 index9 alt1">`[1,] 0.4667732 1.234185 1.280043 2.081554 2.591618`</div>

<div class="line number11 index10 alt2">`[2,] 0.3897914 2.407168 2.030388 3.190009 3.865416`</div>

<div class="line number12 index11 alt1">`[3,] 1.637852  6.867441 2.927759 8.144164 8.688782`</div>

</div>

 |

</div>

</div>

You can choose between combining using cbind() or rbind() depending on whether you want the output from the inner loop to form the columns or rows of the output. There’s lots more magic to be done with .combine. You can find the details in the informative article [Using The foreach Package](http://r.adu.org.za/web/packages/foreach/vignettes/foreach.pdf) by Steve Weston.

You can also use foreach() to loop over multiple variables simultaneously.

<div>

<div id="highlighter_455552" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5, m = 1:5) %do%` `max.eig``(n, m)`</div>

<div class="line number2 index1 alt1">`[[1]]`</div>

<div class="line number3 index2 alt2">`[1] 0.2448898`</div>

<div class="line number5 index4 alt2">`[[2]]`</div>

<div class="line number6 index5 alt1">`[1] 3.037161`</div>

<div class="line number8 index7 alt1">`[[3]]`</div>

<div class="line number9 index8 alt2">`[1] 4.313644`</div>

<div class="line number11 index10 alt2">`[[4]]`</div>

<div class="line number12 index11 alt1">`[1] 11.49438`</div>

<div class="line number14 index13 alt1">`[[5]]`</div>

<div class="line number15 index14 alt2">`[1] 9.850941`</div>

</div>

 |

</div>

</div>

But this is still all serial…

# Filtering

One final capability before we move on to parallel execution, is the ability to add in a filter within the foreach() statement.

<div>

<div id="highlighter_44256" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `library``(numbers)`</div>

<div class="line number2 index1 alt1">`>`</div>

<div class="line number3 index2 alt2">`>` `foreach``(n = 1:100, .combine = c) %:%` `when` `(``isPrime``(n)) %do% n`</div>

<div class="line number4 index3 alt1">`[1]  2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97`</div>

</div>

 |

</div>

</div>

Here we identify the prime numbers between 1 and 100 by simply looping through the entire sequence of values and selecting only those that satisfy the condition in the when() clause. Of course, there are more efficient ways to do this, but this notation is rather neat.

# Going Parallel

Making the transition from serial to parallel is as simple as changing %do% to %dopar%.

<div>

<div id="highlighter_999873" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `foreach``(n = 1:5) %dopar%` `max.eig``(n, 1)`</div>

<div class="line number2 index1 alt1">`[[1]]`</div>

<div class="line number3 index2 alt2">`[1] 0.7085695`</div>

<div class="line number5 index4 alt2">`[[2]]`</div>

<div class="line number6 index5 alt1">`[1] 2.358641`</div>

<div class="line number8 index7 alt1">`[[3]]`</div>

<div class="line number9 index8 alt2">`[1] 2.492679`</div>

<div class="line number11 index10 alt2">`[[4]]`</div>

<div class="line number12 index11 alt1">`[1] 1.24261`</div>

<div class="line number14 index13 alt1">`[[5]]`</div>

<div class="line number15 index14 alt2">`[1] 1.993046`</div>

<div class="line number17 index16 alt2">`Warning message:`</div>

<div class="line number18 index17 alt1">`executing %dopar% sequentially: no parallel backend registered`</div>

</div>

 |

</div>

</div>

The warning gives us pause for thought: maybe it was not quite that simple? Yes, indeed, there are additional requirements. You need first to choose a parallel backend. And here, again, there are a few options. We will start with the most accessible, which is the multicore backend.

# Multicore

Multicore processing is provided by the doMC library. You need to load the library and tell it how many cores you want to use.

<div>

<div id="highlighter_629959" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `library``(doMC)`</div>

<div class="line number2 index1 alt1">`>` `registerDoMC``(cores=4)`</div>

</div>

 |

</div>

</div>

Let’s make a comparison between serial and parallel execution times.

<div>

<div id="highlighter_204694" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `library``(rbenchmark)`</div>

<div class="line number2 index1 alt1">`>`</div>

<div class="line number3 index2 alt2">`>` `benchmark``(`</div>

<div class="line number4 index3 alt1">`+    ` `foreach``(n = 1:50) %do%` `max.eig``(n, 1),`</div>

<div class="line number5 index4 alt2">`+    ` `foreach``(n = 1:50) %dopar%` `max.eig``(n, 1)`</div>

<div class="line number6 index5 alt1">`+ )`</div>

<div class="line number7 index6 alt2">`test replications elapsed relative user.self sys.self user.child sys.child`</div>

<div class="line number8 index7 alt1">`1   ` `foreach``(n = 1:50) %do%` `max.eig``(n, 1)          100  15.723    1.618    15.721    0.000      0.000     0.000`</div>

<div class="line number9 index8 alt2">`2` `foreach``(n = 1:50) %dopar%` `max.eig``(n, 1)          100   9.720    1.000     2.537    0.732     17.589     4.436`</div>

</div>

 |

</div>

</div>

The overall execution time is reduced, but not by the factor of 4 that one might expect. This is due to the additional burden of having to distribute the job over the multiple cores. The tradeoff between communication and computation is one of the major limitations of parallel computing, but if computations are lengthy and there is not too much data to move around then the gains can be excellent.

On a single machine you are limited by the number of cores. But if you have access to a cluster then you can truly take things to another level.

# Cluster

The foreach() functionality can be applied to a cluster using the doSNOW library. We will start by using doSNOW to create a collection of R instances on a single machine using a SOCK cluster.

<div>

<div id="highlighter_98884" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `library``(doSNOW)`</div>

<div class="line number2 index1 alt1">`> cluster =` `makeCluster``(4, type =` `"SOCK"``)`</div>

<div class="line number3 index2 alt2">`>` `registerDoSNOW``(cluster)`</div>

<div class="line number4 index3 alt1">`>`</div>

<div class="line number5 index4 alt2">`>` `benchmark``(`</div>

<div class="line number6 index5 alt1">`+    ` `foreach``(n = 1:50) %do%` `max.eig``(n, 1),`</div>

<div class="line number7 index6 alt2">`+    ` `foreach``(n = 1:50) %dopar%` `max.eig``(n, 1)`</div>

<div class="line number8 index7 alt1">`+ )`</div>

<div class="line number9 index8 alt2">`test replications elapsed relative user.self sys.self user.child sys.child`</div>

<div class="line number10 index9 alt1">`1   ` `foreach``(n = 1:50) %do%` `max.eig``(n, 1)          100  14.052    1.284    14.089     0.00          0         0`</div>

<div class="line number11 index10 alt2">`2` `foreach``(n = 1:50) %dopar%` `max.eig``(n, 1)          100  10.943    1.000     4.856     0.06          0         0`</div>

<div class="line number12 index11 alt1">`>` `#`</div>

<div class="line number13 index12 alt2">`>` `stopCluster``(cluster)`</div>

</div>

 |

</div>

</div>

There is an improvement in execution time which is roughly comparable to what we got with the multicore implementation. Note that when you are done, you need to shut down the cluster.

Next we will create an [MPI](http://en.wikipedia.org/wiki/Message_Passing_Interface) cluster consisting of 20 threads.

<div>

<div id="highlighter_763142" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`> cluster =` `makeCluster``(20, type =` `"MPI"``)`</div>

<div class="line number2 index1 alt1">`>` `#`</div>

<div class="line number3 index2 alt2">`>` `registerDoSNOW``(cluster)`</div>

<div class="line number4 index3 alt1">`>` `#`</div>

<div class="line number5 index4 alt2">`>` `benchmark``(`</div>

<div class="line number6 index5 alt1">`+    ` `foreach``(n = 1:100) %do%` `max.eig``(n, 1),`</div>

<div class="line number7 index6 alt2">`+    ` `foreach``(n = 1:100) %dopar%` `max.eig``(n, 1)`</div>

<div class="line number8 index7 alt1">`+ )`</div>

<div class="line number9 index8 alt2">`test replications elapsed relative user.self sys.self user.child sys.child`</div>

<div class="line number10 index9 alt1">`1   ` `foreach``(n = 1:100) %do%` `max.eig``(n, 1)          100  62.111    3.114    62.105    0.000          0         0`</div>

<div class="line number11 index10 alt2">`2` `foreach``(n = 1:100) %dopar%` `max.eig``(n, 1)          100  19.943    1.000    19.939    0.001          0         0`</div>

</div>

 |

</div>

</div>

There is an improvement in performance, with the parallel job running roughly 3 times as quickly.

How about a slightly more complicated example? We will try running some bootstrap calculations. We start out with the serial implementation.

<div>

<div id="highlighter_44391" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`> random.data <-` `matrix``(``rnorm``(1000000), ncol = 1000)`</div>

<div class="line number2 index1 alt1">`>`</div>

<div class="line number3 index2 alt2">`> bmed <-` `function``(d, n)` `median``(d[n])`</div>

<div class="line number4 index3 alt1">`>`</div>

<div class="line number5 index4 alt2">`>` `library``(boot)`</div>

<div class="line number6 index5 alt1">`>` `#`</div>

<div class="line number7 index6 alt2">`>` `sapply``(1:100,` `function``(n) {``sd``(``boot``(random.data[, n], bmed, R = 10000)$t)})`</div>

<div class="line number8 index7 alt1">`[1] 0.03959383 0.03705808 0.04345169 0.04027020 0.04038000 0.05223590`</div>

<div class="line number9 index8 alt2">`[7] 0.04238710 0.03780378 0.03158105 0.04990962 0.03533659 0.04369453`</div>

<div class="line number10 index9 alt1">`[13] 0.04268809 0.03905804 0.04213135 0.03996430 0.04406709 0.04104289`</div>

<div class="line number11 index10 alt2">`[19] 0.03970051 0.04600647 0.03246924 0.04691756 0.03842184 0.04490416`</div>

<div class="line number12 index11 alt1">`[25] 0.04186847 0.04438831 0.04127071 0.03891882 0.03047418 0.03638098`</div>

<div class="line number13 index12 alt2">`[31] 0.05250030 0.03841815 0.05274663 0.03883077 0.03425073 0.04040601`</div>

<div class="line number14 index13 alt1">`[37] 0.03424269 0.03531023 0.04018262 0.03151492 0.03342666 0.03742966`</div>

<div class="line number15 index14 alt2">`[43] 0.04937554 0.03497177 0.04394860 0.03767637 0.02899806 0.04270962`</div>

<div class="line number16 index15 alt1">`[49] 0.04088265 0.03809354 0.03927284 0.03844624 0.03456490 0.04081791`</div>

<div class="line number17 index16 alt2">`[55] 0.03875243 0.04397634 0.04147273 0.03937905 0.03670778 0.03159038`</div>

<div class="line number18 index17 alt1">`[61] 0.04563407 0.03438879 0.04191963 0.04736964 0.04071846 0.04237484`</div>

<div class="line number19 index18 alt2">`[67] 0.03437641 0.03939834 0.03492293 0.03902924 0.03777660 0.04770606`</div>

<div class="line number20 index19 alt1">`[73] 0.04097508 0.04040914 0.04188157 0.03584112 0.04030294 0.03580566`</div>

<div class="line number21 index20 alt2">`[79] 0.03357913 0.03319093 0.04652214 0.04150011 0.03612597 0.03582600`</div>

<div class="line number22 index21 alt1">`[85] 0.03911643 0.04717892 0.03998664 0.04566421 0.03753487 0.03868689`</div>

<div class="line number23 index22 alt2">`[91] 0.03837865 0.04003132 0.03136855 0.03592450 0.03633709 0.04108870`</div>

<div class="line number24 index23 alt1">`[97] 0.04439740 0.04032455 0.03027182 0.04239404`</div>

</div>

 |

</div>

</div>

First we generated a big array of normally distributed random numbers. Then we used sapply to calculate bootstrap estimates for the standard deviation of the median for each columns of the matrix.

The parallel implementation requires a little more work: first we need to make the global data (the random matrix and the bootstrap function) available across the cluster.

<div>

<div id="highlighter_151043" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`>` `clusterExport``(cluster,` `c``(``"random.data"``,` `"bmed"``))`</div>

</div>

 |

</div>

</div>

Then we spread the jobs out over the cluster nodes. We will do this first using clusterApply(), which is part of the snow library and is the cluster analogue of sapply(). It returns a list, so to get a nice compact representation we use unlist().

<div>

<div id="highlighter_455677" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`> results =` `clusterApply``(cluster, 1:100,` `function``(n) {`</div>

<div class="line number2 index1 alt1">`+    ` `library``(boot)`</div>

<div class="line number3 index2 alt2">`+    ` `sd``(``boot``(random.data[, n], bmed, R = 10000)$t)`</div>

<div class="line number4 index3 alt1">`+ })`</div>

<div class="line number5 index4 alt2">`>` `head``(``unlist``(results))`</div>

<div class="line number6 index5 alt1">`[1] 0.03879663 0.03722502 0.04283553 0.03963994 0.04067666 0.05230591`</div>

</div>

 |

</div>

</div>

The foreach implementation is a little neater.

<div>

<div id="highlighter_991379" class="syntaxhighlighter nogutter  r">

| 

<div class="container">

<div class="line number1 index0 alt2">`results =` `foreach``(n = 1:100, .combine = c) %dopar% {`</div>

<div class="line number2 index1 alt1">`library``(boot);` `sd``(``boot``(random.data[, n], bmed, R = 10000)$t)`</div>

<div class="line number3 index2 alt2">`}`</div>

<div class="line number4 index3 alt1">`head``(results)`</div>

<div class="line number5 index4 alt2">`[1] 0.03934909 0.03742790 0.04307101 0.03969632 0.03994723 0.05211977`</div>

<div class="line number6 index5 alt1">`>`</div>

<div class="line number7 index6 alt2">`>` `stopCluster``(cluster)`</div>

</div>

 |

</div>

</div>

The key in both cases is that the boot library must be loaded on each of the cluster nodes as well so that its functionality is available. Simply loading the library on the root node is not enough!

# Conclusion

Using the parallel computing functionality in R via the foreach package has completely transformed my workflow. Jobs that have previously run for a few days on my desktop machine now complete in a few hours on a 128 node cluster.

<script type="text/javascript">var vglnk = { key: '949efb41171ac6ec1bf7f206d57e90b8' }; (function(d, t) { var s = d.createElement(t); s.type = 'text/javascript'; s.async = true; s.src = '//cdn.viglink.com/api/vglnk.js'; var r = d.getElementsByTagName(t)[0]; r.parentNode.insertBefore(s, r); }(document, 'script'));</script>

<div id="jp-relatedposts" class="jp-relatedposts" style="display: block;">

### _Related_

<div class="jp-relatedposts-items jp-relatedposts-items-visual jp-relatedposts-grid ">

<div class="jp-relatedposts-post jp-relatedposts-post0 jp-relatedposts-post-nothumbs" data-post-id="75267" data-post-format="false">[](https://www.r-bloggers.com/parallel-r-loops-in-windows-and-linux/ "Parallel R Loops in Windows and Linux

Parallel computation may seem difficult to implement and a pain to use, but it is actually quite simple to use. The foreach package provides the basic loop structure, which can utilize various parallel backends to execute the loop in parallel. First, let's go over the basic structure of a foreach…")

#### [Parallel R Loops in Windows and Linux](https://www.r-bloggers.com/parallel-r-loops-in-windows-and-linux/ "Parallel R Loops in Windows and Linux

Parallel computation may seem difficult to implement and a pain to use, but it is actually quite simple to use. The foreach package provides the basic loop structure, which can utilize various parallel backends to execute the loop in parallel. First, let's go over the basic structure of a foreach…")

Parallel computation may seem difficult to implement and a pain to use, but it is actually quite simple to use. The foreach package provides the basic loop structure, which can utilize various parallel backends to execute the loop in parallel. First, let's go over the basic structure of a foreach…

January 17, 2012

In "R bloggers"

</div>

<div class="jp-relatedposts-post jp-relatedposts-post1 jp-relatedposts-post-nothumbs" data-post-id="49597" data-post-format="false">[](https://www.r-bloggers.com/simple-examplehow-to-use-foreach-and-dosnow-packages-for-parallel-computation/ "Simple example:How to use foreach and doSNOW packages for parallel computation.

update************************************************************************************************ I checked whether this example was run collectly or not in Windows XP(32bit) only !  ************************************************************************************************ In R language, the members at Revolution R provide foreach and doSNOW packages for parallel computation. these packages allow us to compute things in parallel. So, we start to install these packages. install.packages("foreach")install.packages("doSNOW") Created…")

#### [Simple example:How to use foreach and doSNOW packages for parallel computation.](https://www.r-bloggers.com/simple-examplehow-to-use-foreach-and-dosnow-packages-for-parallel-computation/ "Simple example:How to use foreach and doSNOW packages for parallel computation.

update************************************************************************************************ I checked whether this example was run collectly or not in Windows XP(32bit) only !  ************************************************************************************************ In R language, the members at Revolution R provide foreach and doSNOW packages for parallel computation. these packages allow us to compute things in parallel. So, we start to install these packages. install.packages("foreach")install.packages("doSNOW") Created…")

update************************************************************************************************ I checked whether this example was run collectly or not in Windows XP(32bit) only !  ************************************************************************************************ In R language, the members at Revolution R provide foreach and doSNOW packages for parallel computation. these packages allow us to compute things in parallel. So, we start to install these packages. install.packages("foreach")install.packages("doSNOW") Created…

February 6, 2011

Similar post

</div>

<div class="jp-relatedposts-post jp-relatedposts-post2 jp-relatedposts-post-thumbs" data-post-id="116408" data-post-format="false">[![Large scale eigenvalue decomposition and SVD with rARPACK](https://i0.wp.com/www.r-bloggers.com/wp-content/uploads/2016/02/VfmfWJi.jpg?fit=1000%2C622&ssl=1&resize=350%2C200)](https://www.r-bloggers.com/large-scale-eigenvalue-decomposition-and-svd-with-rarpack/ "Large scale eigenvalue decomposition and SVD with rARPACK

In January 2016, I was honored to receive an “Honorable Mention” of the John Chambers Award 2016\. This article was written for R-bloggers, whose builder, Tal Galili, kindly invited me to write an introduction to the rARPACK package. A Short Story of rARPACK Eigenvalue decomposition is a commonly used technique…")

#### [Large scale eigenvalue decomposition and SVD with rARPACK](https://www.r-bloggers.com/large-scale-eigenvalue-decomposition-and-svd-with-rarpack/ "Large scale eigenvalue decomposition and SVD with rARPACK

In January 2016, I was honored to receive an “Honorable Mention” of the John Chambers Award 2016\. This article was written for R-bloggers, whose builder, Tal Galili, kindly invited me to write an introduction to the rARPACK package. A Short Story of rARPACK Eigenvalue decomposition is a commonly used technique…")

In January 2016, I was honored to receive an “Honorable Mention” of the John Chambers Award 2016\. This article was written for R-bloggers, whose builder, Tal Galili, kindly invited me to write an introduction to the rARPACK package. A Short Story of rARPACK Eigenvalue decomposition is a commonly used technique…

February 21, 2016

In "R bloggers"

</div>

</div>

</div>

<aside class="mashsb-container mashsb-main mashsb-stretched" onrj5fv="" hidden="">

<div class="mashsb-box" onrj5fv="" hidden="">

<div class="mashsb-count mash-small" style="float:left;">

<div class="counts mashsbcount">28</div>

<span class="mashsb-sharetext">SHARES</span></div>

<div class="mashsb-buttons">[<span class="icon"></span><span class="text">Share</span>](https://www.facebook.com/sharer.php?u=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F)[<span class="icon"></span><span class="text">Tweet</span>](https://twitter.com/intent/tweet?text=The%20Wonders%20of%20foreach&url=https://www.r-bloggers.com/the-wonders-of-foreach/&via=Rbloggers)</div>

</div>

</aside>

<div style="border: 1px solid; background: none repeat scroll 0 0 #EDEDED; margin: 1px; font-size: 13px;">

<div style="text-align: center;">To **leave a comment** for the author, please follow the link and comment on their blog: **[Exegetic Analytics » R](http://www.exegetic.biz/blog/2013/08/the-wonders-of-foreach/)**.</div>

* * *

[R-bloggers.com](https://www.r-bloggers.com/) offers **[daily e-mail updates](https://feedburner.google.com/fb/a/mailverify?uri=RBloggers)** about [R](https://www.r-project.org/ "The R Project for Statistical Computing") news and [tutorials](https://www.r-bloggers.com/search/tutorial "R tutorials") on topics such as: [Data science](https://www.r-bloggers.com/search/data%20science "Data science"), [Big Data,](https://www.r-bloggers.com/search/Big%20Data "Big Data") [R jobs](https://www.r-users.com/ "R jobs"), visualization ([ggplot2](https://www.r-bloggers.com/search/ggplot2 "ggplot and ggplot2 tutorials"), [Boxplots](https://www.r-bloggers.com/search/boxplot "Boxplots using lattice and ggplot2 tutorials"), [maps](https://www.r-bloggers.com/search/map "Maps and gis"), [animation](https://www.r-bloggers.com/search/animation "Animation in R")), programming ([RStudio](https://www.r-bloggers.com/search/RStudio "RStudio IDE for R"), [Sweave](https://www.r-bloggers.com/search/sweave "Sweave and literate programming"), [LaTeX](https://www.r-bloggers.com/search/LaTeX "LaTeX in R"), [SQL](https://www.r-bloggers.com/search/SQL "SQL and databases"), [Eclipse](https://www.r-bloggers.com/search/eclipse "Eclipse IDE for R"), [git](https://www.r-bloggers.com/search/git "git and github, Version Control System"), [hadoop](https://www.r-bloggers.com/search/hadoop "Large data in R using Hadoop"), [Web Scraping](https://www.r-bloggers.com/search/Web+Scraping "Web Scraping of google, facebook, yahoo, twitter and more using R")) statistics ([regression](https://www.r-bloggers.com/search/regression "Regressions and ANOVA analysis tutorials"), [PCA](https://www.r-bloggers.com/search/PCA "principal component analysis tutorial"), [time series](https://www.r-bloggers.com/search/time+series "Time series"), [trading](https://www.r-bloggers.com/search/trading "finance trading")) and more...</div>

* * *

* * *

<div style="border: 1px solid #EB9349; background: none repeat scroll 0 0 #FDEADA; text-align: center; margin: 10px; font-size: 16px;">If you got this far, why not **<u>subscribe for updates</u>** from the site? Choose your flavor: [e-mail](http://feedburner.google.com/fb/a/mailverify?uri=RBloggers), [twitter](https://twitter.com/#!/rbloggers), [RSS](http://feeds.feedburner.com/RBloggers), or [facebook](http://www.facebook.com/pages/R-bloggers/191414254890)...</div>

<div class="social4i" style="height:29px;" onrj5fv="" hidden="">

<div class="social4in" style="height:29px;float: left;">

<div class="socialicons s4fblike" style="float:left;margin-right: 10px;" onrj5fv="" hidden="">

<div class="fb-like fb_iframe_widget" data-href="https://www.r-bloggers.com/the-wonders-of-foreach/" data-send="true" data-layout="button_count" data-width="100" data-height="21" data-show-faces="false" onrj5fv="" hidden="" fb-xfbml-state="rendered" fb-iframe-plugin-query="app_id=&amp;container_width=0&amp;height=21&amp;href=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F&amp;layout=button_count&amp;locale=en_US&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=100"><span style="vertical-align: bottom; width: 111px; height: 20px;"><iframe name="fe7a49dc49d3f8" width="100px" height="21px" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" title="fb:like Facebook Social Plugin" src="https://www.facebook.com/plugins/like.php?app_id=&amp;channel=https%3A%2F%2Fstaticxx.facebook.com%2Fconnect%2Fxd_arbiter%2Fr%2F0sTQzbapM8j.js%3Fversion%3D42%23cb%3Df11222d82b4c856%26domain%3Dwww.r-bloggers.com%26origin%3Dhttps%253A%252F%252Fwww.r-bloggers.com%252Ff13959dd16d1716%26relation%3Dparent.parent&amp;container_width=0&amp;height=21&amp;href=https%3A%2F%2Fwww.r-bloggers.com%2Fthe-wonders-of-foreach%2F&amp;layout=button_count&amp;locale=en_US&amp;sdk=joey&amp;send=true&amp;show_faces=false&amp;width=100" style="border: none; visibility: visible; display: none !important; width: 111px; height: 20px;" hidden="" class=""></iframe></span></div>

</div>

</div>

</div>

</div>

</div>
